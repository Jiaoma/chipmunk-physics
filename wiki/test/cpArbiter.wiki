#summary Arbiters are collision pairs between shapes that are used with the collision callbacks.

=Chipmunk Collision Pairs: `cpArbiter`=

First of all, why are they called arbiters? The short answer is that Box2D called them that way back in the day when I was looking at the source for it before it came the Box2D physics engine. An arbiter is like a judge, a person that has authority to  settle disputes between two people. It was a fun name and was shorter to type than !CollisionPair. :p

Originally arbiters were going to be an internal data type that Chipmunk used that would have no real use to anybody externally. In Chipmunk 4.x and earlier, only a single callback hook was provided for handling collision events that was triggered every step that to shapes were touching. This made it non-trivial to track when objects started and stopped touching as the user would have to record and process this separately. Many people, including myself, wanted to get collision begin/separate events and eventually I realized that information was already being stored in the arbiter cache that the Chipmunk maintains. With some changes to the collision callback API, that information is now exposed to the user. Internally, arbiters are used primarily for solving collision impulses. To external users, you can simply think of them as a weird type used in collision callbacks.

==Memory Management==

You should never need to create an arbiter, nor will you ever need to free one as they are handled by the space. More importantly, because they are handled by the space you should never hold onto a reference to an arbiter as you don't know when they will be destroyed. Use them within the callback where they are given to you and then forget about them or copy out the information you need from them.

==Helper Functions==

{{{
void cpArbiterGetShapes(cpArbiter *arb, cpShape **a, cpShape **b)
#define CP_ARBITER_GET_SHAPES(arb, a, b) cpShape *a, *b; cpArbiterGetShapes(arb, &a, &b);
}}}
 Get the shapes in the order that they were defined in the collision handler associated with this arbiter. If you defined the handler as `cpSpaceAddCollisionHandler(space, 1, 2, ...)`, you you will find that `a->collision_type == 1` and `b->collision_type == 2`. The convenience macro defines and initializes the two shape variables for you.

{{{
void cpArbiterIgnore(cpArbiter *arb)
}}}
 Calling this function on an arbiter will cause Chipmunk to ignore the collision tracked by this arbiter until the shapes separate starting on the next call to `cpSpaceStep()`. (The `separate()` callback will still be called) This allows you to reject a collision the same way that a `begin()` callback can.

 <b>NOTE:</b> If you call this function from the `preStep()` callback, it does not reject the collision until the next time step. Make sure you also return `false` if that is what you intended.

{{{
int cpArbiterIsFirstContact(cpArbiter *arb)
}}}
 Returns true if this is the first step that an arbiter existed. You can use this from preSolve and postSolve to know if a collision between two shapes is new without needing to flag a boolean in your begin callback.

{{{
cpVect cpArbiterGetNormal(cpArbiter *arb, int i)
}}}
 Returns the collision normal for the i'th contact point, flipping it if necessary. *Note:* Currently due to how Chipmunk's collision detection is implemented, the collision normals will be the same for all collision points. You can simply do `cpArbiterGetNormal(arb, 0)` and not have to check each contact point.

{{{
cpVect cpArbiterGetPoint(cpArbiter *arb, int i)
}}}
 Returns the position of the i'th collision point.

{{{
cpVect cpArbiterTotalImpulse(cpArbiter *arb);
cpVect cpArbiterTotalImpulseWithFriction(cpArbiter *arb);
}}}
 Returns the impulse that was applied this step to resolve the collision. Calling this function outside of a postStep callback function is undefined. Enabling elastic iterations will cause you to get incorrect results, this is a known bug.

==Struct Definitions==

It's unlikely that you'll need to interact with a cpArbiter struct directly as the collision helper functions should provide most functionality that people will need. One exception is the `e`, and `u` fields. By default, Chipmunk multiplies the friction and elasticity values of to shapes together to determine what values to use when solving the collision. This mostly works, but in many cases is simply not flexible enough. If you are running into problems with that, you can change the values calculated for `e` and `u` in a preSolve callback.

{{{
typedef struct cpArbiter{
	// Information on the contact points between the objects.
	int numContacts;
	cpContact *contacts;
	
	// The two shapes involved in the collision.
	cpShape *a, *b;
	
	// Calculated before calling the pre-solve collision handler
	// Override them with custom values if you want specialized behavior
	cpFloat e;
	cpFloat u;
	 // Used for surface_v calculations, implementation may change
	cpVect surface_vr;
	
	// Time stamp of the arbiter. (from cpSpace)
	int stamp;
	
	// Are the shapes swapped in relation to the collision handler?
	int swappedColl;
	
	struct cpCollisionHandler *handler;
} cpArbiter
}}}

{{{
typedef struct cpContact {
	// Contact point and normal.
	cpVect p, n;
	// Penetration distance.
	cpFloat dist;
} cpContact
}}}