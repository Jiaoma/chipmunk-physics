#summary Description of how Chipmunk does collision detection

= Collision Detection in Chipmunk =

In order to make collision detection in Chipmunk as fast as possible, the process is broken down into several steps. While I've tried to keep it as simple as possible, it can get a little hard to follow for the uninitiated.

== Spatial Hashing ==

Chipmunk uses a spatial hash for its broad phase culling. Spatial hashes are very efficient for a scene made up of consistently sized objects. It basically works by taking the axis aligned bounding boxes for all the objects in the scene, mapping them onto an infinite sized grid, then mapping those grid cells onto a finite sized hash table. This way, you only have to check collisions between objects in the same hash table cells, and mapping the objects onto the grid can be done fairly quickly. Objects in the same hash table cells tend to be very close together, and therefore more likely to be colliding.

The downside is that in order to get the best performance out of a spatial hash, you have to tune the size of the grid cells and the size of the hash table so you don't get too many false positives. You want to make the grid size 1/2 the size of the estimated average size of a bounding box so that objects will be split into about 4 grid cells each. To make it unlikely that objects in different grid cells will map to the same hash cell, use about 10x as many hash cells as objects. (memory is abundant and cheap) For more information see [cpSpace].

Things to keep in mind:
 * Using too small a grid size means that your objects will be split into many grid cells which means that the spatial hash will spend a lot of time filling empty hash cells for just one object and rarely finding any with multiple objects. Making the grid size too big means that you will be putting a lot of objects into a single hash cell, and collisions will have to be checked between all of them.
 * Using too small of a hash table means that you will map too many far away objects into a single hash cell. Using too many means that the hash table will have to spend a lot of time doing clears and rehashes.

For more information on spatial hashing in general, [http://graphics.ethz.ch/~brunoh/download/CollisionDetectionHashing_VMV03.pdf Optimized Spatial Hashing for Collision Detection of Deformable Objects] is a good paper that covers all the basics.

== Collision Filtering ==

After the spatial hash figures out pairs of shapes that are likely to be near each other, it passes them back to the space to perform some additional filtering on the pairs. If the pairs pass all the filters, then Chipmunk will test if the shapes are actually overlapping. These tests are much faster than the shape to shape collision checks, so use these if you can to reject collisions early instead of using callbacks if you can.

 * *Bounding Box Test:* The shapes are not colliding if their bounding boxes are not overlapping.
 * *Layer Test:* The shapes are not colliding if they don't occupy and of the same layers. (the bitwise and of their layer masks is 0)
 * *Group Test:* Shapes shouldn't collide with other shapes in the same non-zero group.

== Primitive Collision Detection ==

The most expensive test that you can do to see if shapes should collide is to actually check based on their geometry. Circle to circle and circle to line collisions are very cheap still however. Poly to poly collisions get more expensive as the number of vertexes increases. Simpler shapes make for faster collisions (and more importantly fewer collision points for the solver to run).

Chipmunk creates and maintains a list of the colliding objects at this points so that it can process physics on them, but you have one last and very flexible way of discarding the collisions.

== Collision Handler Filtering ==

After checking if two shapes overlap Chipmunk will look to see if you have defined a collision handler for the collision types of the shapes. This gives you a large amount of flexibility to process collisions events, but also gives you a very flexible way to filter out collisions. The return value of the begin and preSolve callback determines whether or not the colliding pair of shapes is discarded or not. Returning true will keep the pair, false will discard it. If you don't define a handler for the given collision_types, Chipmunk will call the space's default handler, which by default is defined to simply accept all collisions.

While using callbacks to filter collisions is the most flexible way, keep in mind that by the time your callback is called all of the most expensive collision detection has already been done. For contact heavy simulations, the time spent finding collisions is small compared to the time spent solving the physics for them so it may not be a big deal. Still, use layers or groups first if you can.