=Chipmunk spaces: `cpSpace`=

Spaces in Chipmunk are the basic unit of simulation. You add rigid bodies, shapes and joints to it and then step them all forward together through time. Adding powerful collision detection and physics to your game couldn't be simpler.

==Iterations. What are they?==

Chipmunk uses an iterative solver to figure out the forces between objects in the space. What this means is that it builds a big list of all of the collisions, joints, and other constraints between the bodies and makes several passes over the list considering each constraint individually. The number of passes it makes is the iteration count, and each iteration makes the solution more accurate. If you use too many iterations, the physics should look nice and solid, but may use up too much CPU time. If you use too few iterations, the simulation may seem mushy or bouncy when the objects should be solid. Setting the number of iterations lets you balance between CPU usage and the accuracy of the physics.


===Elastic Iterations===

New in Chipmunk 4 was the addition of elastic iterations. Previously, shapes did not stack nicely if their elasticity was anything other than 0. Elastic iterations separates solving the elastic bounce from the solidity of a normal resting contact. If you are having problems with your elastic shapes jittering when they come to a rest, you will need to use more elastic iterations.

==Static Shapes:==

Static shapes? Chipmunk optimizes collision detection against shapes that do not move. These unmoving, or static shapes, are designated as such by the way they are added to the space. A normal shape is added by using `cpSpaceAddShape()` while a static shape is added using `cpSpaceAddStaticShape()`.

In order to create a static shape, you need to create a cpBody with an infinite mass and moment of inertia to attach the shape to. If you don't don't use an infinite mass the body will gain velocity from colliding with other objects. This will cause it to behave strangely when colliding with other objects. You also don't want to add such a body to a space as it will gain velocity from gravity. 

If you do move a body that a static shape is attached to, you *MUST* let Chipmunk know about it by calling `cpSpaceRehashStatic()`. If you don't, the precalculated collision detection data cached by the space will not get updated and collisions will be missed.

==Type Definitions and Memory Management Functions:==

{{{
typedef struct cpSpace{
	// *** User definable fields
	
	// Number of iterations to use in the impulse solver to solve contacts.
	int iterations;
	
	// Number of iterations to use in the impulse solver to solve elastic collisions.
	int elasticIterations;
	
	// Default gravity to supply when integrating rigid body motions.
	cpVect gravity;
	
	// Default damping to supply when integrating rigid body motions.
	cpFloat damping;
} cpSpace;
}}}

 * `iterations` and `elasticIterations` allow you to control the accuracy of the solver. See the section on iterations above for an explanation.
 * `gravity` is the value passed to each body's velocity integration function when it's integrated in the space.
 * `damping` is used in a calculation before passing it on to the velocity integration function like `gravity` is. The calculation currently applied ensures stability with variable sized time steps, but the implementation has issues and may be changed in the future.

{{{
cpSpace* cpSpaceAlloc(void)
cpSpace* cpSpaceInit(cpSpace *space)
cpSpace* cpSpaceNew()

void cpSpaceDestroy(cpSpace *space)
void cpSpaceFree(cpSpace *space)
}}}

 More standard Chipmunk memory functions.

{{{
void cpSpaceFreeChildren(cpSpace *space)
}}}

 This function will free all of the shapes, bodies and joints that have been added to `space`. Does not free `space`. You will still need to call `cpSpaceFree()` on your own. You will probably never use this in a real game, as your gamestate or game controller should manage removing and freeing objects from the space.

==Operations:==

{{{
void cpSpaceAddShape(cpSpace *space, cpShape *shape)
void cpSpaceAddStaticShape(cpSpace *space, cpShape *shape)
void cpSpaceAddBody(cpSpace *space, cpBody *body)
void cpSpaceAddConstraint(cpSpace *space, cpConstraint *constraint)

void cpSpaceRemoveShape(cpSpace *space, cpShape *shape)
void cpSpaceRemoveStaticShape(cpSpace *space, cpShape *shape)
void cpSpaceRemoveBody(cpSpace *space, cpBody *body)
void cpSpaceRemoveConstraint(cpSpace *space, cpConstraint *constraint)
}}}

 These functions add and remove shapes, bodies and joints from `space`. See the section on Static Shapes above for an explanation of what a static shape is and how it differs from a normal shape.

==Spatial Hash Management Functions:==

Chipmunk uses a spatial hash to accelerate it's collision detection. While it's not necessary to interact with the hash directly. The current API does expose some of this at the space level to allow you to tune it.

{{{
void cpSpaceResizeStaticHash(cpSpace *space, cpFloat dim, int count)
void cpSpaceResizeActiveHash(cpSpace *space, cpFloat dim, int count)
}}}

 The spatial hashes used by Chipmunk's collision detection are fairly size sensitive. `dim` is the size of the hash cells. Setting `dim` to the average collision shape size is likely to give the best performance. Setting 'dim' too small will cause the shape to be inserted into many cells, setting it too low will cause too many objects into the same slot.

Using the spatial has visualization in the demo program you can see what I mean. The grey squares represent cells in the spatial hash. The darker the cell, the more objects have been mapped into that cell. A good `dim` size is when your objects fit nicely into the grid:

http://chipmunk-physics.googlecode.com/svn/wiki/images/hash_just_right.png

Use too small a size and Chipmunk has to insert each object into a lot of cells which can be expensive.

http://chipmunk-physics.googlecode.com/svn/wiki/images/hash_too_small.png

Use too big of a size and a lot of shapes will fit into each cell. Each shape has to be checked against every other shape in the cell, so this makes for a lot of unnecessary collision checks.

http://chipmunk-physics.googlecode.com/svn/wiki/images/hash_too_big.png

 `count` is the _suggested_ minimum number of cells in the hash table. If there are too few cells, the spatial hash will return many false positives. Too many cells will be hard on the cache and waste memory. the  Setting `count` to ~10x the number of objects in the space is probably a good starting point. Tune from there if necessary. By default, `dim` is 100.0, and `count` is 1000. The new demo program has a visualizer for the static hash. You can use this to get a feel for how to size things up against the spatial hash.

{{{
void cpSpaceRehashStatic(cpSpace *space)
}}}

 Rehashes the shapes in the static spatial hash. You only need to call this if you move any static shapes.

==Simulating the Space:==

{{{
void cpSpaceStep(cpSpace *space, cpFloat dt)
}}}

 Update the space for the given time step. Using a fixed time step is _highly_ recommended. Doing so will increase the efficiency of the contact persistence, requiring an order of magnitude fewer iterations to resolve the collisions in the usual case.

=Notes:=

 * When removing objects from the space, make sure you remove any other objects that reference it. For instance, when you remove a body, remove the joints and shapes attached to it.
 * The number of iterations, and the size of the time step determine the quality of the simulation. More iterations, or smaller time steps increase the quality.
 * Because static shapes are only rehashed when you request it, it's possible to use a much higher `count` argument to `cpHashResizeStaticHash()` than to `cpHashResizeActiveHash()`. Doing so will use more memory though.