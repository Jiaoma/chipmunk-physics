=Chipmunk spaces: `cpSpace`=

Spaces in Chipmunk are the basic unit of simulation. You add rigid bodies, shapes and joints to it and then step them all forward together through time.

==Iterations. What are they?==

Chipmunk uses an iterative solver to figure out the forces between objects in the space. What this means is that it builds a big list of all of the collisions, joints, and other constraints between the bodies and makes several passes over the list considering each constraint individually. The number of passes it makes is the iteration count, and each iteration makes the solution more accurate. If you use too many iterations, the physics should look nice and solid, but may use up too much CPU time. If you use too few iterations, the simulation may seem mushy or bouncy when the objects should be solid. Setting the number of iterations lets you balance between CPU usage and the accuracy of the physics.


===Elastic Iterations===

New in Chipmunk 4 was the addition of elastic iterations. Previously, shapes did not stack nicely if their elasticity was anything other than 0. Elastic iterations separates solving the elastic bounce from the solidity of a normal resting contact. If you are having problems with your elastic shapes jittering when they come to a rest, you will need to use more elastic iterations.

==Static Shapes:==

Static shapes? Chipmunk optimizes collision detection against shapes that do not move. These unmoving, or static shapes, are designated as such by the way they are added to the space. A normal shape is added by using `cpSpaceAddShape()` while a static shape is added using `cpSpaceAddStaticShape()`.

In order to create a static shape, you need to create a cpBody with an infinite mass and moment of inertia to attach the shape to. If you don't don't use an infinite mass the body will gain velocity from colliding with other objects. This will cause it to behave strangely when colliding with other objects. You also don't want to add such a body to a space as it will gain velocity from gravity. 

If you do move a body that a static shape is attached to, you *MUST* let Chipmunk know about it by calling `cpSpaceRehashStatic()`. If you don't, the precalculated collision detection data cached by the space will not get updated and collisions will be missed.

==Type Definitions and Memory Management Functions:==

{{{
typedef struct cpSpace{
	// *** User definable fields
	
	// Number of iterations to use in the impulse solver to solve contacts.
	int iterations;
	
	// Number of iterations to use in the impulse solver to solve elastic collisions.
	int elasticIterations;
	
	// Default gravity to supply when integrating rigid body motions.
	cpVect gravity;
	
	// Default damping to supply when integrating rigid body motions.
	cpFloat damping;
	
	// *** Internally Used Fields
	// cpSpace contains many internally used fields that you probably could care less about.
} cpSpace;
}}}

 * `iterations` and `elasticIterations` allow you to control the accuracy of the solver. See the section on iterations above for an explanation.
 * `gravity` is the value passed to each body's velocity integration function when it's integrated in the space.
 * `damping` is used in a calculation before passing it on to the velocity integration function like `gravity` is. The calculation currently applied ensures stability with variable sized time steps, but the implementation has issues and may be changed in the future.

{{{
cpSpace* cpSpaceAlloc(void)
cpSpace* cpSpaceInit(cpSpace *space, int iterations)
cpSpace* cpSpaceNew(int iterations)

void cpSpaceDestroy(cpSpace *space)
void cpSpaceFree(cpSpace *space)
}}}

 More standard Chipmunk memory functions.

{{{
void cpSpaceFreeChildren(cpSpace *space)
}}}

 This function will free all of the shapes, bodies and joints that have been added to `space`. Does not free `space`. You will still need to call `cpSpaceFree()` on your own.

==Operations:==

{{{
void cpSpaceAddShape(cpSpace *space, cpShape *shape)
void cpSpaceAddStaticShape(cpSpace *space, cpShape *shape)
void cpSpaceAddBody(cpSpace *space, cpBody *body)
void cpSpaceAddConstraint(cpSpace *space, cpConstraint *constraint)

void cpSpaceRemoveShape(cpSpace *space, cpShape *shape)
void cpSpaceRemoveStaticShape(cpSpace *space, cpShape *shape)
void cpSpaceRemoveBody(cpSpace *space, cpBody *body)
void cpSpaceRemoveConstraint(cpSpace *space, cpConstraint *constraint)
}}}

 These functions add and remove shapes, bodies and joints from `space`. See the section on Static Shapes above for an explanation of what a static shape is.

==Collision Callbacks==

Chipmunk allows you to register callback functions, called collision pair functions, to be called when shapes with certain pairs of collision types collide. For instance, say you make a collision type for the player, and another collision type for an enemy. You can add a collision callback to be called when a shape tagged with the player collision type collides with a shape tagged with the enemy collision type.

The collision callback function is passed a fair amount of information on the collision including the points and normals of those points where the objects are colliding. You can also pass a `data` pointer when you register the collision pair callback to be passed in. Lastly, because of how the internals of Chipmunk work, if you want to use the normals in the contact point set, you will have to multiply them by the `normal_coef` in order for them to be guaranteed to be pointer from shape `a` to shape `b`.

A feature that may be unique to Chipmunk is that the return value from the collision callback gives you one last chance to filter out a collision based on the specific collision details or just something more rigorous than can be done using layers and groups. Keep in mind that filtering by layer or group as faster as it performs the expensive primitive collision detection after that but before calling the callback.

Lastly, Chipmunk implements the default behavior that shapes collide by default using a real collision pair function. The default function simply returns true for all collisions, but you can replace this function to implement something more complex.

{{{
typedef struct cpContact{
        // Contact point and normal.
        cpVect p, n;
        // Penetration distance.
        cpFloat dist;
        
	...
} cpContact;
}}}

 * `p` is the contact point in world coordinates
 * `n` is the normal in world space, f you multiply it by the `normal_coef` supplied to you in the collision callback it will always point from the colliding surface of shape `a` to the colliding surface of shape `b`
 * `dist` is how far the two objects are penetrating each other

{{{
typedef int (*cpCollFunc)(cpShape *a, cpShape *b, cpContact *contacts, int numContacts, cpFloat normal_coef, void *data)
void cpSpaceAddCollisionPairFunc(cpSpace *space, cpCollisionType a, cpCollisionType b, cpCollFunc func, void *data)
void cpSpaceRemoveCollisionPairFunc(cpSpace *space, cpCollisionType a, cpCollisionType b)
void cpSpaceSetDefaultCollisionPairFunc(cpSpace *space, cpCollFunc func, void *data)
}}}

* You only need to make a single callback for any pair of objects. If
  you make a callback for A and B, any collision between an A and a B
  will send the callback the types in the same order as what they were
  registered in the callback definition. That is why the `normal_coef`
  parameter exists, Chipmunk may need to swap the shape order to
  satisfy that, but it already has contact information defined the
  other way around.

*WARNING:* While it is supported to remove shapes from a space within a collision callback, you cannot free them. Doing so will almost certainly cause a delayed crash.

==Querying a Space==

Point queries are useful for things like simple mouse selection or a simple sensor. It allows you to find out what shapes overlap a certain point.

{{{
typedef void (*cpSpacePointQueryFunc)(cpShape *shape, void *data)
void cpSpacePointQuery(cpSpace *space, cpVect point, cpLayers layers, cpLayers group, cpSpacePointQueryFunc func, void *data)

cpShape *cpSpacePointQueryFirst(cpSpace *space, cpVect point, cpLayers layers, cpLayers group)
}}}

 `cpSpacePointQuery()` uses a callback to iterate all of the shapes that overlap the given point. The callback will be called with each shape and will be passed the same `data` pointer passed to `cpSpacePointQuery()`.

 `cpSpacePointQueryFirst()`simply returns a single shape (there probably only is one anyway) or NULL if there were no overlapping shapes.

 With both functions, layers and group work just like when colliding with other shapes to allow you to filter out certain shapes.

==Spatial Hash Management Functions:==

Chipmunk uses a spatial hash to accelerate it's collision detection. While it's not necessary to interact with the hash directly. The current API does expose some of this at the space level to allow you to tune it.

{{{
void cpSpaceResizeStaticHash(cpSpace *space, cpFloat dim, int count)
void cpSpaceResizeActiveHash(cpSpace *space, cpFloat dim, int count)
}}}

 The spatial hashes used by Chipmunk's collision detection are fairly size sensitive. `dim` is the size of the hash cells. Setting `dim` to half the average collision shape size is likely to give the best performance. Setting 'dim' too small will cause the shape to be inserted into many cells, setting it too low will cause too many objects into the same slot.

 `count` is the _suggested_ minimum number of cells in the hash table. If there are too few cells, the spatial hash will return many false positives. Too many cells will be hard on the cache and waste memory. the  Setting `count` to ~10x the number of objects in the space is probably a good starting point. Tune from there if necessary.

 By default, `dim` is 100.0, and `count` is 1000.

{{{
void cpSpaceRehashStatic(cpSpace *space)
}}}

 Rehashes the shapes in the static spatial hash. You only need to call this if you move a static shapes.

==Simulating the Space:==

{{{
void cpSpaceStep(cpSpace *space, cpFloat dt)
}}}

 Update the space for the given time step. Using a fixed time step is _highly_ recommended. Doing so will increase the efficiency of the contact persistence, requiring an order of magnitude fewer iterations to resolve the collisions in the usual case.

=Notes:=

 * When removing objects from the space, make sure you remove any other objects that reference it. For instance, when you remove a body, remove the joints and shapes attached to it.
 * The number of iterations, and the size of the time step determine the quality of the simulation. More iterations, or smaller time steps increase the quality.
 * Because static shapes are only rehashed when you request it, it's possible to use a much higher `count` argument to `cpHashResizeStaticHash()` than to `cpHashResizeStaticHash()`. Doing so will use more memory though.