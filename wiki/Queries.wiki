#summary Segment and point queries against spaces and individual shapes.

=Queries=

Chipmunk currently supports two kinds of spatial queries, segment and point. Either type can be done efficiently against an entire space, or against individual shapes. Both types of queries take a collision group and layer that are used to filter matches out using the same rules used for filtering collisions between shapes. See [cpShape] for more information. If you don't want to filter out any matches, use -1 for the layers and 0 as the group.

==Point Queries==

Point queries are useful for things like mouse picking and simple sensors.

{{{int cpShapePointQuery(cpShape *shape, cpVect p)}}}
 Check if the given point lies within the shape.

{{{
typedef void (*cpSpacePointQueryFunc)(cpShape *shape, void *data);
void cpSpacePointQuery(cpSpace *space, cpVect point, cpLayers layers, cpGroup group, cpSpacePointQueryFunc func, void *data)
}}}
 Query `space` at `point` filtering out matches with the given `layers` and `group`. `func` is called for each shape found along with the `data` argument passed to `cpSpacePointQuery()`.

{{{cpShape *cpSpacePointQueryFirst(cpSpace *space, cpVect point, cpLayers layers, cpGroup group)}}}
 Query `space` at `point` and return the first shape found matching the given `layers` and `group`. Returns NULL if no shape was found.

==Segment Queries==

Segment queries are like ray casting, but because Chipmunk uses a spatial hash to process collisions, it cannot process infinitely long queries like a ray. In practice this is still very fast and you don't need to worry too much about the performance as long as you aren't using very long segments for your queries.

{{{
typedef struct cpSegmentQueryInfo{
	struct cpShape *shape; // shape that was hit, NULL if no collision
	cpFloat t; // Distance along query segment, will always be in the range [0, 1].
	cpVect n; // normal of hit surface
} cpSegmentQueryInfo;
}}}
 Segment queries return more information than just a simple yes or no, they also return where a shape was hit and it's surface normal at the hit point. `t` is the percentage between the query start and end points. If you need the hit point in world space or the absolute distance from start, see the segment query helper functions later.

{{{int cpShapeSegmentQuery(cpShape *shape, cpVect a, cpVect b, cpSegmentQueryInfo *info)}}}
 Check if the line segment from `a` to `b` intersects the shape. `info` must be a valid pointer to a `cpSegmentQueryInfo` structure which will be initialized if the line segment intersects.

{{{
typedef void (*cpSpaceSegmentQueryFunc)(cpShape *shape, cpFloat t, cpVect n, void *data)
int cpSpaceSegmentQuery(cpSpace *space, cpVect start, cpVect end, cpLayers layers, cpGroup group, cpSpaceSegmentQueryFunc func, void *data)
}}}
  Query `space` along the line segment from `start` to `end` filtering out matches with the given `layers` and `group`. `func` is called with the normalized distance along the line and surface normal for each shape found along with the `data` argument passed to `cpSpacePointQuery()`.

{{{cpShape *cpSpaceSegmentQueryFirst(cpSpace *space, cpVect start, cpVect end, cpLayers layers, cpGroup group, cpSegmentQueryInfo *out)}}}
 Query `space` along the line segment from `start` to `end` filtering out matches with the given `layers` and `group`. Only the first shape encountered is returned and the search is short circuited.

===Segment Query Helper Functions===

{{{cpVect cpSegmentQueryHitPoint(cpVect start, cpVect end, cpSegmentQueryInfo info)}}}
 Return the hit point in world coordinates where the segment first intersected with the shape.

{{{cpFloat cpSegmentQueryHitDist(cpVect start, cpVect end, cpSegmentQueryInfo info)}}}
 Return the absolute distance where the segment first hit the shape.