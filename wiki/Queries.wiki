#summary Segment and point queries against spaces and individual shapes.

=Queries=

Chipmunk currently supports 3 kinds of spatial queries: point, segment and bounding box. All types of queries take a collision group and layer that are used to filter matches out using the same rules used for filtering collisions between shapes. See [cpShape] for more information. If you don't want to filter out any matches, use `CP_ALL_LAYERS` for the layers and `CP_NO_GROUP` as the group.

==Point Queries==

Point queries are useful for things like mouse picking and simple sensors.

{{{
int cpShapePointQuery(cpShape *shape, cpVect p)
}}}
 Check if the given point lies within the shape.

{{{
typedef void (*cpSpacePointQueryFunc)(cpShape *shape, void *data);
void cpSpacePointQuery(cpSpace *space, cpVect point, cpLayers layers, cpGroup group, cpSpacePointQueryFunc func, void *data)
}}}
 Query `space` at `point` filtering out matches using the given `layers` and `group`. `func` is called for each shape found along with the `data` argument passed to `cpSpacePointQuery()`.

{{{
cpShape *cpSpacePointQueryFirst(cpSpace *space, cpVect point, cpLayers layers, cpGroup group)
}}}
 Query `space` at `point` and return the first shape found matching the given `layers` and `group`. Returns `NULL` if no shape was found.

==Segment Queries==

Segment queries are like ray casting, but because Chipmunk uses a spatial hash to process collisions, it cannot process infinitely long queries like a ray. In practice this is still very fast and you don't need to worry too much about the performance as long as you aren't using very long segments for your queries.

{{{
typedef struct cpSegmentQueryInfo{
	struct cpShape *shape; // shape that was hit, NULL if no collision
	cpFloat t; // Distance along query segment, will always be in the range [0, 1].
	cpVect n; // normal of hit surface
} cpSegmentQueryInfo;
}}}
 Segment queries return more information than just a simple yes or no, they also return where a shape was hit and it's surface normal at the hit point. `t` is the percentage between the query start and end points. If you need the hit point in world space or the absolute distance from start, see the segment query helper functions later.

{{{
int cpShapeSegmentQuery(cpShape *shape, cpVect a, cpVect b, cpSegmentQueryInfo *info)
}}}
 Check if the line segment from `a` to `b` intersects the shape. `info` must be a valid pointer to a `cpSegmentQueryInfo` structure which will be initialized with the raycast info.

{{{
typedef void (*cpSpaceSegmentQueryFunc)(cpShape *shape, cpFloat t, cpVect n, void *data)
int cpSpaceSegmentQuery(cpSpace *space, cpVect start, cpVect end, cpLayers layers, cpGroup group, cpSpaceSegmentQueryFunc func, void *data)
}}}
  Query `space` along the line segment from `start` to `end` filtering out matches using the given `layers` and `group`. `func` is called with the normalized distance along the line and surface normal for each shape found along with the `data` argument passed to `cpSpacePointQuery()`.

{{{
cpShape *cpSpaceSegmentQueryFirst(cpSpace *space, cpVect start, cpVect end, cpLayers layers, cpGroup group, cpSegmentQueryInfo *info)
}}}
 Query `space` along the line segment from `start` to `end` filtering out matches using the the given `layers` and `group`. Only the first shape encountered is returned and the search is short circuited. Returns `NULL` if no shape was found. The info struct pointed to by `info` will be initialized with the raycast info unless `info` is NULL.

===Segment Query Helper Functions===

{{{
cpVect cpSegmentQueryHitPoint(cpVect start, cpVect end, cpSegmentQueryInfo info)
}}}
 Return the hit point in world coordinates where the segment first intersected with the shape.

{{{
cpFloat cpSegmentQueryHitDist(cpVect start, cpVect end, cpSegmentQueryInfo info)
}}}
 Return the absolute distance where the segment first hit the shape.

==Bounding Box Queries==

{{{
typedef void (*cpSpaceBBQueryFunc)(cpShape *shape, void *data);
void cpSpaceBBQuery(cpSpace *space, cpBB bb, cpLayers layers, cpGroup group, cpSpaceBBQueryFunc func, void *data);
}}}
 Query `space` over the area of `bb` filtering out matches using the given `layers` and `group`. `func` is called for each shape found along with the `data` argument passed to `cpSpaceBBQuery()`. The bounding box of all shapes passed to the callback overlap the given bounding box, but the shapes themselves might not overlap the box. This function is meant to be an efficient way to find objects in an area, but not a detailed intersection test.

==Examples==

This is the mouse button handler function from the demo app. On mouse down, it finds the shape under the mouse if there is one and adds a joint to it so that you can drag it around.
{{{
static void
click(int button, int state, int x, int y)
{
	if(button == GLUT_LEFT_BUTTON){
		if(state == GLUT_DOWN){
			cpVect point = mouseToSpace(x, y);
		
			cpShape *shape = cpSpacePointQueryFirst(space, point, GRABABLE_MASK_BIT, 0);
			if(shape){
				cpBody *body = shape->body;
				mouseJoint = cpPivotJointNew2(mouseBody, body, cpvzero, cpBodyWorld2Local(body, point));
				mouseJoint->maxForce = 50000.0f;
				mouseJoint->biasCoef = 0.15f;
				cpSpaceAddConstraint(space, mouseJoint);
			}
		} else if(mouseJoint){
			cpSpaceRemoveConstraint(space, mouseJoint);
			cpConstraintFree(mouseJoint);
			mouseJoint = NULL;
		}
	}
}
}}}

Shoot a laser through a space, find the first shape it hits. We want to draw particles where the laser beam enters and exits the shape.
{{{
cpSegmentQueryInfo info;
if(cpSpaceSegmentQueryFirst(space, a, b, -1, 0, &info)){
	cpSegmentQueryInfo info2;
	cpShapeSegmentQuery(info.shape, b, a, &info2);
	
	cpVect enterPoint = cpSegmentQueryHitPoint(a, b, info);
	cpVect exitPoint = cpSegmentQueryHitPoint(b, a, info2);
}
}}}